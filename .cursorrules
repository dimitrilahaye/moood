# Moood ‚Äî Cursor Rules

## Raison d'√™tre
Moood permet de noter ses √©motions au fil de chaque jour. Et ainsi pouvoir observer la progression de ses humeurs jour par jour.

## UX
Tons pastels, calme, s√©r√©nit√©.
Bar√®me des mooods :

| Note | √âtat d'esprit | √âmotion dominante | Couleur | Pastille |
| --- | --- | --- | --- | --- |
| **5** | G√©nial | Joie, gratitude, √©nergie | Vert vif | üü¢ |
| **4** | Bien | Calme, satisfaction, s√©r√©nit√© | Vert clair | üü¢ |
| **3** | Neutre | Fatigue l√©g√®re, routine, "√ßa va" | Jaune / Beige | üü° |
| **2** | Bof | Stress, tristesse, agacement | Orange | üü† |
| **1** | Mauvais | Col√®re, d√©prime, √©puisement | Rouge | üî¥ |

## Architecture (3 couches + inversion de d√©pendances)
- Dossiers sous `src/`:
  - `core/`: r√®gles m√©tier pures (entit√©s, types, services, use-cases). Aucune d√©pendance DOM/Storage.
  - `datasource/`: persistance via LocalStorage. Impl√©mente les interfaces (ports) d√©finies par `core/`.
  - `presentation/`: gestion du DOM (event listeners, √©l√©ments, MAJ du DOM). Consomme les interfaces `core/` via injection.
- Inversion de d√©pendances:
  - `core/` expose des interfaces (ports) pour les acc√®s donn√©es et l'al√©atoire.
  - `datasource/` fournit les adaptateurs qui impl√©mentent ces ports.
  - `presentation/` compose le tout (composition root) et injecte les impl√©mentations dans les use-cases `core/`.
- R√®gles d'import:
  - `core` ‚Üí importe seulement `core`.
  - `datasource` ‚Üí peut importer `core`, jamais `presentation`.
  - `presentation` ‚Üí peut importer `core` et la composition, jamais directement `datasource`.
- **OBLIGATOIRE**: La couche `presentation` ne doit JAMAIS importer directement les adaptateurs `datasource`.
- **OBLIGATOIRE**: La couche `presentation` doit TOUJOURS utiliser les use-cases de `core` pour acc√©der aux donn√©es.
- **OBLIGATOIRE**: Les use-cases `core` encapsulent la logique m√©tier et injectent les ports `datasource`.

## Typage strict via JSDoc (JavaScript vanilla)
- Utiliser `// @ts-check` en t√™te des fichiers pertinents.
- JSDoc syst√©matique:
  - `@typedef`, `@property` pour les entit√©s (√âl√®ve, Cours, Personnage, Emotion, Impro, etc.).
  - `@interface` pour les ports (ex: `StoragePort`, `RandomPort`), `@implements` c√¥t√© adaptateurs.
  - `@param`, `@returns` pour les fonctions publiques; `@template` si besoin.
- Les fonctions de `core` sont pures et testables (pas de DOM/Storage).

## Contraintes m√©tier

1. Sauvegarder son mood (home page)
1.A Date et time picker fix√© par d√©faut √† aujourd'hui et l'heure actuelle (pr√©cision heure : minute)
1.B S√©lectionner le jour et l'heure puis le mood
1.C Valider la s√©lection. Persistence dans le local-storage

2. CRUD de son mood
2.A Lister tous les moods par jour
2.B Supprimer un mood
2.C Modifier un mood

3. Bilans
3.A Avoir un r√©capitulatif des moods par jour
3.B Avoir un r√©capitulatif des moods par semaine
3.C Avoir un r√©capitulatif des moods par mois
3.D Pouvoir copier dans le presse-papier un bilan pour l'envoyer apr√®s par mail par exemple

## Organisation sugg√©r√©e
- `src/core/`: `entities/`, `ports/` (StoragePort, RandomPort), `usecases/`, `utils/`.
- `src/datasource/`: `localstorage/` (impl√©mentations des ports `core`).
- `src/presentation/`: `components/`, `pages/`, `compose/` (composition root qui instancie et injecte).

## Architecture des pages
```
src/presentation/pages/[page-name]/
‚îú‚îÄ‚îÄ index.js          # Point d'entr√©e principal (renderPage)
‚îú‚îÄ‚îÄ sections.js       # Fonctions de cr√©ation des sections DOM
‚îú‚îÄ‚îÄ handlers.js       # Gestionnaires d'√©v√©nements (event handlers)
‚îú‚îÄ‚îÄ utils.js          # Fonctions utilitaires sp√©cifiques √† la page
‚îî‚îÄ‚îÄ constants.js      # Constantes et messages sp√©cifiques √† la page
```

### R√¥les de chaque fichier

#### `index.js` (Point d'entr√©e)
- **Responsabilit√©** : Orchestration g√©n√©rale, √©tat de l'application, composition des sections
- **Contenu** :
  - Fonction `render[PageName]Page({ root, params, deps })` avec **arguments nomm√©s**
  - Gestion de l'√©tat local de la page (variables `let`)
  - Initialisation des donn√©es (appels aux use-cases)
  - Composition des sections principales
  - Fonctions de mise √† jour de l'UI (`updateUI()`, `updateXXX()`)
  - **Appels aux fonctions expos√©es** par sections.js, handlers.js, utils.js avec **arguments nomm√©s**
  - **Injection des d√©pendances** (use-cases, √©tat, callbacks) dans les fonctions appel√©es
- **Imports** : sections, handlers, constants, use-cases
- **Pattern** : √âtat local + fonctions de mise √† jour + composition + injection de d√©pendances

#### `sections.js` (Cr√©ation DOM)
- **Responsabilit√©** : Cr√©ation des √©l√©ments DOM et sections visuelles
- **Contenu** :
  - Fonctions `create[SectionName]Section({ ... })` qui retournent des `HTMLElement` avec **arguments nomm√©s**
  - Logique pure de cr√©ation DOM (pas d'event listeners)
  - Fonctions pures qui prennent en arguments tout ce dont elles ont besoin
- **Pattern** : Fonctions pures qui cr√©ent et retournent des √©l√©ments DOM
- **Imports** : AUCUN import (fonctions pures uniquement)

#### `handlers.js` (Gestionnaires d'√©v√©nements)
- **Responsabilit√©** : Cr√©ation des event listeners pour les interactions utilisateur
- **Contenu** :
  - Fonctions `create[ActionName]Handler({ ... })` qui retournent des **event listeners** avec **arguments nomm√©s**
  - Logique de gestion des √©v√©nements DOM (preventDefault, extraction des donn√©es du formulaire, etc.)
  - Appels aux use-cases pour toute logique m√©tier
  - Gestion des erreurs et feedback utilisateur
  - Fonctions pures qui prennent en arguments tout ce dont elles ont besoin
- **Pattern** : Factory functions qui retournent des **fonctions event listener**
- **Imports** : AUCUN import (fonctions pures uniquement)
- **R√®gles m√©tier** : D√âL√âGU√âES aux use-cases (pas de validation dans handlers)
- **Usage** : Les fonctions retourn√©es sont inject√©es dans `utils.js` via `addEventListener()`

#### `utils.js` (Utilitaires sp√©cifiques)
- **Responsabilit√©** : Composants r√©utilisables et fonctions utilitaires
- **Contenu** :
  - Fonctions `create[ComponentName]({ ... })` pour composants r√©utilisables avec **arguments nomm√©s**
  - Fonctions utilitaires sp√©cifiques √† la page
  - Helpers pour feedback visuel, cr√©ation DOM, etc.
  - **Injection des event listeners** via `addEventListener()` avec les handlers de `handlers.js`
- **Pattern** : Fonctions utilitaires pures et composants r√©utilisables
- **Imports** : AUCUN import (fonctions pures uniquement)
- **R√®gles m√©tier** : AUCUNE logique m√©tier (d√©l√©gation aux use-cases)

#### `constants.js` (Configuration)
- **Responsabilit√©** : Constantes, messages et configuration sp√©cifiques
- **Contenu** :
  - Objets de configuration (`[PAGE]_CONFIG`)
  - Messages utilisateur (`[PAGE]_MESSAGES`)
  - Constantes m√©tier sp√©cifiques √† la page
- **Pattern** : Export d'objets de configuration et messages

### R√®gles de d√©coupage

1. **Une page = un dossier** : Chaque page complexe doit avoir son propre dossier
2. **S√©paration des responsabilit√©s** : Chaque fichier a une responsabilit√© claire et unique
3. **Imports directionnels** :
   - `index.js` ‚Üí importe sections, handlers, constants, use-cases
   - `sections.js` ‚Üí AUCUN import (fonctions pures uniquement)
   - `handlers.js` ‚Üí AUCUN import (fonctions pures uniquement)
   - `utils.js` ‚Üí AUCUN import (fonctions pures uniquement)
   - `constants.js` ‚Üí aucun import (pur)
4. **√âtat local dans index.js** : L'√©tat de la page reste dans le fichier principal
5. **Fonctions de mise √† jour** : Centralis√©es dans `index.js` pour maintenir la coh√©rence
6. **R√©utilisabilit√©** : Les composants dans `utils.js` doivent √™tre r√©utilisables
7. **Orchestration par index.js** : `index.js` appelle les fonctions expos√©es par les autres fichiers en leur passant toutes leurs d√©pendances (use-cases, √©tat, callbacks)
8. **R√®gles m√©tier** : TOUTES les r√®gles/invariants m√©tier doivent √™tre g√©r√©es via les use-cases
9. **Typage JSDoc** : Tous les fichiers doivent √™tre typ√©s avec `// @ts-check` et JSDoc complet
10. **Arguments nomm√©s** : TOUTES les fonctions doivent utiliser des arguments nomm√©s (objet avec propri√©t√©s nomm√©es)

### Exemple concret du flux handlers.js ‚Üí utils.js

```javascript
// handlers.js (AUCUN import)
export function createCourseFormSubmitHandler({ coursesUseCase, onRefresh }) {
  return async (e) => {
    e.preventDefault();
    const form = /** @type {HTMLFormElement} */ (e.target);
    const input = /** @type {HTMLInputElement} */ (form.querySelector('input[name="courseName"]'));
    const name = input.value.trim();
    
    if (!name) return;
    
    try {
      await coursesUseCase.create(name);
      input.value = '';
      await onRefresh();
    } catch (error) {
      console.error('Erreur lors de la cr√©ation du cours:', error);
    }
  };
}

// utils.js (AUCUN import)
export function createCourseForm({ onSubmitHandler }) {
  const form = document.createElement('form');
  // ... cr√©ation du DOM ...
  form.addEventListener('submit', onSubmitHandler); // ‚Üê Handler inject√©
  return form;
}

// index.js (orchestrateur)
const formSubmitHandler = createCourseFormSubmitHandler({ coursesUseCase: deps.coursesUseCase, onRefresh: refresh });
const form = createCourseForm({ onSubmitHandler: formSubmitHandler });
```

## Arguments nomm√©s (OBLIGATOIRE - TOUTES LES FONCTIONS)
- **TOUTES** les fonctions d√©clar√©es dans le projet doivent utiliser des arguments nomm√©s
- **Pattern** : `function name({ param1, param2, param3 })` au lieu de `function name(param1, param2, param3)`
- **JSDoc** : `@param {{ param1: Type1, param2: Type2, param3: Type3 }} params`
- **Appels** : `functionName({ param1: value1, param2: value2, param3: value3 })`
- **S'applique √†** :
  - ‚úÖ Toutes les fonctions export√©es
  - ‚úÖ Toutes les fonctions internes
  - ‚úÖ Toutes les fonctions d√©clar√©es dans les objets retourn√©s par les use-cases
  - ‚úÖ Toutes les fonctions d√©clar√©es dans les objets retourn√©s par les adapters
  - ‚úÖ Tous les use-cases (`core/usecases/`)
  - ‚úÖ Tous les adapters (`datasource/`)
  - ‚úÖ Tous les composants (`presentation/components/`)
  - ‚úÖ Toutes les pages (`presentation/pages/`)
  - ‚úÖ Tous les utilitaires (`core/utils/`, `presentation/pages/*/utils.js`)
  - ‚úÖ Tous les handlers (`presentation/pages/*/handlers.js`)
  - ‚úÖ Toutes les sections (`presentation/pages/*/sections.js`)
  - ‚úÖ Tous les fichiers de composition (`presentation/compose/`)
  - ‚úÖ Tous les fichiers de routage (`presentation/router.js`)
  - ‚úÖ Tous les fichiers principaux (`main.js`)
- **Avantages** :
  - Lisibilit√© maximale : chaque param√®tre est clairement identifi√©
  - Maintenance facilit√©e : ajout de param√®tres sans casser les appels existants
  - S√©curit√© renforc√©e : impossible de passer les arguments dans le mauvais ordre
  - Documentation auto-g√©n√©r√©e : JSDoc avec noms des propri√©t√©s
  - IntelliSense am√©lior√© : meilleure autocompl√©tion dans l'IDE

### Exemples d'arguments nomm√©s (TOUS LES FICHIERS)

```javascript
// ‚ùå AVANT - Arguments positionnels
export function createStudentCard(student, isSelected, onToggle) { ... }
createStudentCard(student, true, handleToggle);

// ‚úÖ APR√àS - Arguments nomm√©s
export function createStudentCard({ student, isSelected, onToggle }) { ... }
createStudentCard({ student, isSelected: true, onToggle: handleToggle });

// ‚ùå AVANT - Use-case avec arguments positionnels
export function createCharactersUseCase(deps) { ... }
createCharactersUseCase({ charactersPort: adapter });

// ‚úÖ APR√àS - Use-case avec arguments nomm√©s
export function createCharactersUseCase({ deps }) { ... }
createCharactersUseCase({ deps: { charactersPort: adapter } });

// ‚ùå AVANT - Adapter avec arguments positionnels
function writeAll(characters) { ... }
writeAll([character, ...characters]);

// ‚úÖ APR√àS - Adapter avec arguments nomm√©s
function writeAll({ characters }) { ... }
writeAll({ characters: [character, ...characters] });

// ‚ùå AVANT - Fonction retourn√©e par use-case avec arguments positionnels
export function createCharactersUseCase({ deps }) {
  return {
    async create(name) { ... },
    async rename(id, newName) { ... }
  };
}

// ‚úÖ APR√àS - Fonction retourn√©e par use-case avec arguments nomm√©s
export function createCharactersUseCase({ deps }) {
  return {
    async create({ name }) { ... },
    async rename({ id, newName }) { ... }
  };
}

// ‚ùå AVANT - Fonction retourn√©e par adapter avec arguments positionnels
export function createCharactersAdapter() {
  return {
    async create(name) { ... },
    async rename(id, newName) { ... }
  };
}

// ‚úÖ APR√àS - Fonction retourn√©e par adapter avec arguments nomm√©s
export function createCharactersAdapter() {
  return {
    async create({ name }) { ... },
    async rename({ id, newName }) { ... }
  };
}

// ‚ùå AVANT - Handler avec arguments positionnels
export function createCourseFormSubmitHandler(coursesUseCase, onRefresh) { ... }
createCourseFormSubmitHandler(deps.coursesUseCase, refresh);

// ‚úÖ APR√àS - Handler avec arguments nomm√©s
export function createCourseFormSubmitHandler({ coursesUseCase, onRefresh }) { ... }
createCourseFormSubmitHandler({ coursesUseCase: deps.coursesUseCase, onRefresh: refresh });

// ‚ùå AVANT - Utilitaire avec arguments positionnels
function migrateKey(oldKey, newKey) { ... }
migrateKey(oldKey, newKey);

// ‚úÖ APR√àS - Utilitaire avec arguments nomm√©s
function migrateKey({ oldKey, newKey }) { ... }
migrateKey({ oldKey, newKey });

// ‚ùå AVANT - Composant avec arguments positionnels
export function renderBurgerMenu(mountOn) { ... }
renderBurgerMenu(menuMount);

// ‚úÖ APR√àS - Composant avec arguments nomm√©s
export function renderBurgerMenu({ mountOn }) { ... }
renderBurgerMenu({ mountOn: menuMount });
```

## PWA & Build
- Vite (vanilla JS) + `vite-plugin-pwa`.
- GitHub Pages: respecter `base` dans `vite.config.js` (ex: `/moood/`).
- Router basique
- Pas de librairies externes hormis pour le build

## Style de code
- Noms explicites; √©viter les abr√©viations obscures.
- Retours pr√©coces; √©viter l'imbrication profonde; pas de `try/catch` superflu.
- Commentaires concis pour invariants et d√©cisions non √©videntes.
- Aucune d√©pendance au DOM/Storage dans `core`.
- **Arguments nomm√©s** : TOUTES les fonctions doivent utiliser des arguments nomm√©s (objet avec propri√©t√©s nomm√©es).
- **Coh√©rence totale** : Aucune exception √† la r√®gle des arguments nomm√©s dans tout le projet.

## Par d√©faut, l'IA doit
- Respecter les couches et l'inversion de d√©pendances.
- **JAMAIS** permettre d'imports directs `datasource` dans `presentation`.
- **TOUJOURS** utiliser les use-cases `core` comme interm√©diaire entre `presentation` et `datasource`.
- √âcrire/mettre √† jour les types via JSDoc.
- Centraliser l'instanciation dans `presentation/compose`.
- Garder `core` pur et ind√©pendant de l'environnement.
- **TOUJOURS** utiliser des arguments nomm√©s pour toutes les fonctions dans tous les fichiers.
- **JAMAIS** cr√©er de fonctions avec des arguments positionnels, peu importe le fichier.
- **V√âRIFIER** que chaque nouvelle fonction suit le pattern `function name({ param1, param2 })`.
- **APPLIQUER** cette r√®gle de mani√®re syst√©matique et coh√©rente dans tout le projet.
- **OBLIGATOIRE** : √Ä chaque refactorisation, supprimer syst√©matiquement le code mort :
  - **Fonctions mortes** : Supprimer toutes les fonctions non utilis√©es (imports, exports, fonctions internes)
  - **Arguments morts** : Supprimer tous les param√®tres non utilis√©s dans les fonctions
  - **Variables mortes** : Supprimer toutes les variables d√©clar√©es mais non utilis√©es
  - **Imports morts** : Supprimer tous les imports non utilis√©s
  - **Code mort** : Identifier et supprimer tout code inaccessible ou redondant